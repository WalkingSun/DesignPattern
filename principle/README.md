# 里氏替换原则(LSP)
面向对象继承优点：
- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；
- 提供代码的重用性；

缺点：
- 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
- 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。

里氏替换原则：
Functions that use pointers or references to base classes mustbe able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象。）

通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类

## 里氏替换原则为良好的继承定义了一个规范：
- 子类必须完全实现父类的方法
如书中所说：玩具枪不能实现杀敌这个行为。
![image-20201122182637376](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/img/image-20201122182637376.png)
ToyGun脱离继承，建立一个独立的父类，为了实现代码复用，可以与AbastractGun建立关联委托关系

注：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承

- 子类可以有自己的个性

子类可以有自己的方法和属性。里氏替换原则可以正着用，但不能反着用，换言之子类出现的地方，父类未必能胜任。
![image-20201122192437506](/Users/zhaoyu/Library/Application Support/typora-user-images/image-20201122192437506.png)
AUG继承了Rifle类，狙击手（Snipper）则直接使用AUG狙击步枪

Sniper 阻击手很依赖枪支（AUG），实现杀敌需要先瞄准再射击，换成父类去执行将是错误的。

- 覆盖或实现父类的方法时输入参数可以被放大

方法中的输入参数称为前置条件，里氏替换原则也要求制定一个契约，就是父类或接口，这种设计方法也叫做Design by Contract（契约设计），同时制定了前置条件和后置条件，前置条件就是你要让我执行，就必须满足我的条件；
后置条件就是我执行完了需要反馈，标准是什么。

书中描述子类没有实现父类的方法，但是因为重载，子类的前置条件范围缩小，在子类执行父类的方法会走到子类的方法，“歪曲”了父类的意图，引起一堆意想不到的业务逻辑混乱。
![image-20201122194606366](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/img/image-20201122194606366.png)
![image-20201122194648477](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/img/image-20201122194648477.png)
![image-20201122194743259](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/img/image-20201122194743259.png)

- 覆写或实现父类的方法时输出结果可以被缩小

父类的一个方法的返回值是一个类型T，子类的相同方法（重载或覆写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，为什么呢？分两种情况，如果是覆写，父类和子类
的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。
如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件。

采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！

# 开放封闭原则
Software entities like classes,modules and functions should be open forextension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）

例子：书籍促销，所有40元以上的书籍9折销售，其他的8折销售小说书进行打折促销；

![image-20201129165244186](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/ws2/image-20201129165244186.png)

增加一个子类OffNovelBook，覆写getPrice方法，高层次的模块（也就是static静态模块区）通过OffNovelBook类产生新的对象，完成业务变化对系统的最小化开发

## 开闭原则重要性
- 开闭原则对测试影响
已经投产的代码，因为业务有变化提出，如果修改原有健壮的代码，需要将原有测试流程重新进行功能测试、单元测试、集成测试及验收，通过扩展，只需测通附加的扩展代码即可；
- 开闭原则提高服用性
减少代码量，避免相同的逻辑分散在多个角落，避免日后的维护人员为了修改一个微小的缺陷或增加新功能而要在整个项目中到处查找相关的代码；
怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可再拆分为止。
- 开闭原则可以提高可维护性
一款软件投产后，维护人员的工作不仅仅是对数据进行维护，还可能要对程序进行扩展，维护人员最乐意做的事情就是扩展一个类，而不是修改一个类；

## 开闭原则运用
- 抽象约束
通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：

第一，通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；

第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；

第三，抽象层尽量保持稳定，一旦确定即不允许修改。还是以书店为例，目前只是销售小说类书籍，单一经营毕竟是有风险的，于是书店新增加了计算机书籍，它不仅包含书籍名称、作者、价格等信息，
还有一个独特的属性：面向的是什么领域，也就是它的范围，比如是和编程语言相关的，还是和数据库相关的，等等

![image-20201129164434100](https://raw.githubusercontent.com/WalkingSun/WindBlog/gh-pages/images/ws2/image-20201129164434100.png)

计算机书籍增加了一个方法，就是获得该书籍的范围，同时继承IBook接口，毕竟计算机书籍也是书籍

- 制定项目章程
在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。

优秀的章程能带给项目带来非常多的好处，如提高开发效率、降低缺陷率、提高团队士气、提高技术成员水平，等等x

- 封装变化
对变化的封装包含两层含义：

第一，将相同的变化封装到一个接口或抽象类中；

第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中；

